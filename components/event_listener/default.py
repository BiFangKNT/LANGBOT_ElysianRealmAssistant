# Auto generated by LangBot Plugin SDK.
# Adapted to encapsulate legacy Elysian Realm assistant logic within the new EventListener component.
from __future__ import annotations

import asyncio
import base64
import hashlib
import time
from pathlib import Path
from typing import Optional

import httpx
import regex as re
import yaml

from langbot_plugin.api.definition.components.common.event_listener import EventListener
from langbot_plugin.api.entities import context, events
from langbot_plugin.api.entities.builtin.platform import message as platform_message

try:
    from langbot_plugin.entities.io.errors import ActionCallTimeoutError
except Exception:  # pragma: no cover - SDK 版本兼容
    ActionCallTimeoutError = None


class DefaultEventListener(EventListener):
    """LangBot event listener encapsulating the Elysian Realm assistant workflow."""

    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self._plugin_root = Path(__file__).resolve().parents[2]
        self._config_path = self._plugin_root / "ElysianRealmConfig.yaml"
        self._cache_dir = self._plugin_root / "cache"
        self.config: dict[str, list[str]] = {}
        self.url_pattern = re.compile(
            rf'''
            ^(?:
                ((.{{0,5}})乐土list) |
                (乐土推荐\d{{0,2}}) |
                (全部乐土推荐) |
                (?P<角色乐土>(.{{1,5}})乐土\d?) |
                (?P<角色流派>(.{{1,5}})(\p{{Han}}{{2}})流) |
                (?P<添加命令>RealmCommand\s+add\s+(\w+)\s+([^,]+(?:,[^,]+)*))
            )$
            ''',
            re.VERBOSE | re.UNICODE,
        )

    async def initialize(self) -> None:
        await super().initialize()
        self.config = await self.load_config()
        await self.clear_cache()

        @self.handler(events.PersonMessageReceived)
        @self.handler(events.GroupMessageReceived)
        async def handle_message(event_context: context.EventContext) -> None:
            message_text = self._extract_text(event_context)
            if not message_text:
                return

            self._log("info", f"乐土攻略助手正在处理消息: {message_text}")

            if not self.url_pattern.search(message_text):
                self._log("info", "乐土攻略助手：格式不匹配，不进行处理")
                return

            optimized_chain = await self.convert_message(message_text, event_context)
            if optimized_chain:
                await self._safe_reply(
                    event_context,
                    optimized_chain,
                    reply_tag="result",
                )

                event_context.prevent_default()
                event_context.prevent_postorder()
            else:
                self._log("info", "消息处理后为空，不进行回复")

    def _extract_text(self, event_context: context.EventContext) -> str:
        message_chain = getattr(event_context.event, "message_chain", None)
        if message_chain:
            text = "".join(
                element.text for element in message_chain if isinstance(element, platform_message.Plain)
            ).strip()
            if text:
                return text

        text_message = getattr(event_context.event, "text_message", None)
        if isinstance(text_message, str):
            return text_message.strip()
        return ""

    async def load_config(self) -> dict[str, list[str]]:
        def _load() -> dict[str, list[str]]:
            if not self._config_path.exists():
                self._log("info", f"配置文件未找到: {self._config_path}")
                return {}
            try:
                with self._config_path.open("r", encoding="utf-8") as file:
                    data = yaml.safe_load(file) or {}
                    return data if isinstance(data, dict) else {}
            except yaml.YAMLError as exc:
                self._log("error", f"解析YAML文件时出错: {exc}")
            except Exception as exc:
                self._log("error", f"加载配置文件时发生未知错误: {exc}")
            return {}

        return await asyncio.to_thread(_load)

    async def convert_message(
        self, message: str, event_context: context.EventContext
    ) -> Optional[platform_message.MessageChain]:
        await self._safe_reply(
            event_context,
            platform_message.MessageChain(
                [
                    platform_message.Plain(
                        text=f"已收到指令：{message}\n正在为您查询攻略……"
                    )
                ]
            ),
            reply_tag="ack",
            suppress_on_failure=True,
        )

        match = self.url_pattern.search(message)
        if match and match.group("添加命令"):
            self._log("debug", "命中添加命令分支")
            return await self.handle_add_command(match.group("添加命令"))

        if message == "乐土list":
            self._log("debug", "命中乐土list全部输出")
            dumped = yaml.dump(self.config, allow_unicode=True) if self.config else "当前无配置数据"
            return platform_message.MessageChain([platform_message.Plain(text=dumped)])

        if message == "全部乐土推荐":
            self._log("debug", "命中全部乐土推荐")
            return await self.handle_recommendation(event_context, is_all=True)

        if "乐土推荐" in message:
            try:
                suffix = message.split("乐土推荐", 1)[1]
                sequence = int(suffix or 1)
            except ValueError:
                sequence = 1
            self._log("debug", f"命中单期乐土推荐，sequence={sequence}")
            return await self.handle_recommendation(event_context, is_all=False, sequence=sequence)

        if "乐土list" in message:
            self._log("debug", "命中模糊乐土list查询")
            return self.handle_list_query(message)

        self._log("debug", "命中角色攻略查询")
        return await self.handle_normal_query(message, event_context)

    async def handle_recommendation(
        self,
        event_context: context.EventContext,
        is_all: bool = False,
        sequence: int = 1,
    ) -> Optional[platform_message.MessageChain]:
        url = "https://bbs-api.miyoushe.com/post/wapi/userPost?uid=5625196"
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
            "Connection": "keep-alive",
        }

        try:
            async with httpx.AsyncClient(headers=headers, timeout=10.0) as client:
                response = await client.get(url)
                response.raise_for_status()
                data = response.json()

                posts = data.get("data", {}).get("list", [])
                pattern = r"往世乐土丨V\d+\.\d+[一二三四五六七八九十]+期推荐角色BUFF表"

                elysian_posts: list[dict] = []
                for post_item in posts:
                    post = post_item.get("post", {})
                    subject = post.get("subject", "")
                    if re.search(pattern, subject):
                        elysian_posts.append(post_item)

                if not elysian_posts:
                    return platform_message.MessageChain(
                        [platform_message.Plain(text="未找到最新的往世乐土推荐文章。")]
                    )

                images = elysian_posts[0].get("post", {}).get("images", [])
                subject = elysian_posts[0].get("post", {}).get("subject", "")
                reply_time = elysian_posts[0].get("post", {}).get("reply_time", "")

                if len(images) <= 1:
                    return platform_message.MessageChain(
                        [platform_message.Plain(text="推荐文章中未包含攻略图片。")]
                    )

                if not (1 <= sequence < len(images)):
                    return platform_message.MessageChain(
                        [
                            platform_message.Plain(
                                text=f"序号超出范围，请输入1至{len(images) - 1}之间的序号。"
                            )
                        ]
                    )

                image_url = images[sequence]
                header_text = (
                    f"标题：{subject}\n更新时间：{reply_time}\n本期乐土推荐为：\n"
                )

                if is_all:
                    image_urls = images[2:]
                    return platform_message.MessageChain(
                        [
                            platform_message.Plain(text=header_text),
                            platform_message.Image(url=image_url),
                            platform_message.Plain(text="\n" + "\n".join(image_urls)),
                        ]
                    )

                return platform_message.MessageChain(
                    [
                        platform_message.Plain(text=header_text),
                        platform_message.Image(url=image_url),
                    ]
                )

        except Exception as exc:
            self._log("error", f"获取推荐攻略时发生错误: {exc}")
            return platform_message.MessageChain(
                [platform_message.Plain(text="获取推荐攻略失败。")]
            )

        return None

    def handle_list_query(self, message: str) -> platform_message.MessageChain:
        query = message.replace("乐土list", "").strip()
        matched_pairs: dict[str, list[str]] = {}
        for key, values in self.config.items():
            if isinstance(values, list) and any(query in value for value in values):
                self._log("info", f"找到匹配: {key}: {values}")
                matched_pairs[key] = values

        if matched_pairs:
            dumped = yaml.dump(matched_pairs, allow_unicode=True)
            return platform_message.MessageChain([platform_message.Plain(text=dumped)])
        return platform_message.MessageChain(
            [platform_message.Plain(text="未找到相关的乐土list信息。")]
        )

    async def handle_normal_query(
        self, message: str, event_context: context.EventContext
    ) -> platform_message.MessageChain:
        for key, values in self.config.items():
            if isinstance(values, list) and message in values:
                image_url = (
                    "https://raw.githubusercontent.com/BiFangKNT/ElysianRealm-Data/"
                    "refs/heads/master/"
                    f"{key}.jpg"
                )
                return platform_message.MessageChain(
                    [
                        platform_message.Plain(text="已为您找到攻略：\n"),
                        platform_message.Image(url=image_url),
                    ]
                )
        return platform_message.MessageChain(
            [platform_message.Plain(text="未找到相关的乐土攻略。")]
        )

    async def get_image(
        self,
        url: str,
        event_context: context.EventContext,
        client: Optional[httpx.AsyncClient] = None,
        preload: bool = False,
    ) -> Optional[platform_message.Image | bool]:
        start_time = self._now()

        def _read_file_bytes(path: Path) -> bytes:
            with path.open("rb") as file:
                return file.read()

        def _write_file_bytes(path: Path, data: bytes) -> None:
            with path.open("wb") as file:
                file.write(data)

        try:
            url_md5 = self._hash_url(url)
            await asyncio.to_thread(lambda: self._cache_dir.mkdir(parents=True, exist_ok=True))
            cache_path = self._cache_dir / f"{url_md5}.jpg"

            if await asyncio.to_thread(cache_path.exists):
                cache_start = self._now()
                self._log("info", f"使用缓存图片: {url_md5}")
                image_data = await asyncio.to_thread(_read_file_bytes, cache_path)
                cache_time = self._now() - cache_start
                self._log("info", f"缓存读取用时: {cache_time:.2f}秒")
                if preload:
                    return True
                return platform_message.Image(
                    base64=base64.b64encode(image_data).decode("utf-8")
                )

            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                "Accept": "image/webp,image/apng,image/*,*/*;q=0.8",
                "Connection": "keep-alive",
            }

            async def _download(active_client: httpx.AsyncClient):
                dns_start = self._now()
                response = await active_client.get(url)
                dns_time = self._now() - dns_start
                self._log("debug", f"DNS解析用时: {dns_time:.2f}秒")
                self._log("debug", f"响应状态: {response.status_code}")

                if response.status_code == 200:
                    content = response.content
                    size_mb = len(content) / (1024 * 1024)
                    download_time = max(self._now() - dns_start, 1e-6)
                    self._log("debug", f"图片大小: {size_mb:.2f}MB")
                    self._log("debug", f"下载用时: {download_time:.2f}秒")
                    self._log("debug", f"下载速度: {size_mb / download_time:.2f}MB/s")

                    save_start = self._now()
                    await asyncio.to_thread(_write_file_bytes, cache_path, content)
                    save_time = self._now() - save_start
                    self._log("debug", f"缓存保存用时: {save_time:.2f}秒")

                    total_time = self._now() - start_time
                    self._log("debug", f"总处理用时: {total_time:.2f}秒")

                    if preload:
                        return True
                    return platform_message.Image(
                        base64=base64.b64encode(content).decode("utf-8")
                    )

                self._log("info", f"下载图片失败，状态码: {response.status_code}")
                if not preload:
                    await self._safe_reply(
                        event_context,
                        platform_message.MessageChain(
                            [
                                platform_message.Plain(
                                    text=f"图片下载失败，状态码: {response.status_code}"
                                )
                            ]
                        ),
                        reply_tag="image-error",
                        suppress_on_failure=True,
                    )
                return False if preload else None

            if client is None:
                self._log("info", "未传入客户端，创建新的 AsyncClient")
                async with httpx.AsyncClient(headers=headers, timeout=10.0) as new_client:
                    return await _download(new_client)
            return await _download(client)

        except Exception as exc:
            total_time = self._now() - start_time
            self._log("error", f"获取图片时发生错误: {exc}")
            self._log("error", f"失败用时: {total_time:.2f}秒")
            return False if preload else None

    async def clear_cache(self, max_age_days: int = 365, max_size_mb: int = 1000) -> None:
        def _clear() -> None:
            if not self._cache_dir.exists():
                return

            current_time = self._now()
            for file in list(self._cache_dir.iterdir()):
                try:
                    if file.stat().st_mtime < current_time - (max_age_days * 86400):
                        file.unlink(missing_ok=True)
                        self._log("info", f"已删除过期缓存文件: {file}")
                except Exception as exc:
                    self._log("warning", f"删除缓存文件失败: {exc}")

            total_size = sum(file.stat().st_size for file in self._cache_dir.iterdir()) / (1024 * 1024)
            if total_size <= max_size_mb:
                return

            files = sorted(
                [(file, file.stat().st_mtime, file.stat().st_size) for file in self._cache_dir.iterdir()],
                key=lambda item: item[1],
            )

            for file, _, size in files:
                if total_size <= max_size_mb:
                    break
                try:
                    file.unlink(missing_ok=True)
                    total_size -= size / (1024 * 1024)
                    self._log("info", f"因空间限制删除缓存文件: {file}")
                except Exception as exc:
                    self._log("warning", f"删除缓存文件失败: {exc}")

        await asyncio.to_thread(_clear)

    async def handle_add_command(self, command: str) -> platform_message.MessageChain:
        try:
            _, _, key, values = command.split(None, 3)
            value_list = [v.strip() for v in values.split(',')]

            def _read_config() -> dict[str, list[str]]:
                if not self._config_path.exists():
                    return {}
                with self._config_path.open("r", encoding="utf-8") as file:
                    data = yaml.safe_load(file) or {}
                    return data if isinstance(data, dict) else {}

            config = await asyncio.to_thread(_read_config)

            if key in config and isinstance(config[key], list):
                config[key].extend(v for v in value_list if v not in config[key])
            else:
                config[key] = value_list

            def _write_config(data: dict[str, list[str]]) -> None:
                with self._config_path.open("w", encoding="utf-8") as file:
                    yaml.dump(data, file, allow_unicode=True, sort_keys=False)

            await asyncio.to_thread(_write_config, config)
            self.config = config

            return platform_message.MessageChain(
                [
                    platform_message.Plain(
                        text=f"已成功添加/更新配置：\n{key}:\n  - "
                        + "\n  - ".join(config[key])
                    )
                ]
            )
        except Exception as exc:
            self._log("error", f"添加配置时发生错误: {exc}")
            return platform_message.MessageChain(
                [platform_message.Plain(text=f"添加配置失败: {exc}")]
            )

    async def _safe_reply(
        self,
        event_context: context.EventContext,
        message_chain: Optional[platform_message.MessageChain],
        reply_tag: str = "result",
        suppress_on_failure: bool = False,
    ) -> None:
        if message_chain is None:
            self._log("debug", f"[{reply_tag}] 跳过空消息链")
            return

        summary = self._summarize_message_chain(message_chain)
        self._log("debug", f"[{reply_tag}] 准备发送 -> {summary}")
        try:
            await event_context.reply(message_chain)
            self._log("debug", f"[{reply_tag}] 消息发送完成")
        except Exception as exc:  # pragma: no cover - 运行时调试
            error_name = exc.__class__.__name__
            if ActionCallTimeoutError and isinstance(exc, ActionCallTimeoutError):
                error_name = "ActionCallTimeoutError"
            self._log("error", f"[{reply_tag}] 调用 reply 失败 ({error_name}): {exc}")
            if suppress_on_failure:
                return
            fallback_chain = platform_message.MessageChain(
                [platform_message.Plain(text=f"发送消息失败 ({error_name}): {exc}")]
            )
            try:
                await event_context.reply(fallback_chain)
            except Exception as nested:  # pragma: no cover - 仅用于调试
                self._log("error", f"[{reply_tag}] 兜底回复依旧失败: {nested}")

    def _summarize_message_chain(self, message_chain: platform_message.MessageChain) -> str:
        try:
            elements = list(message_chain)
        except TypeError:
            elements = list(getattr(message_chain, "items", []))
        parts = []

        def _unwrap(component):
            current = component
            for attr in ("value", "__root__"):
                try:
                    inner = getattr(current, attr)
                except Exception:
                    inner = None
                if inner is not None:
                    current = inner
            return current

        def _safe_get(component, attr):
            try:
                return getattr(component, attr)
            except Exception:
                return None

        for idx, element in enumerate(elements):
            component = _unwrap(element)
            cls_name = component.__class__.__name__

            text_value = _safe_get(component, "text")
            if text_value:
                preview = str(text_value)
                if len(preview) > 24:
                    preview = preview[:24] + "…"
                parts.append(f"{idx}:{cls_name}:{preview}")
                continue

            url_value = _safe_get(component, "url")
            if url_value:
                parts.append(f"{idx}:{cls_name}:url={url_value}")
                continue

            base64_value = _safe_get(component, "base64")
            if base64_value:
                parts.append(f"{idx}:{cls_name}:base64~{len(base64_value)}")
                continue

            parts.append(f"{idx}:{cls_name}")

        joined = ", ".join(parts)
        return f"MessageChain[{joined}]"

    def _hash_url(self, url: str) -> str:
        return hashlib.md5(url.encode()).hexdigest()

    def _now(self) -> float:
        return time.time()

    def _log(self, level: str, message: str) -> None:
        logger = getattr(self.plugin, "logger", None)
        if not logger:
            plugin_ap = getattr(self.plugin, "ap", None)
            logger = getattr(plugin_ap, "logger", None) if plugin_ap else None

        if logger and hasattr(logger, level):
            getattr(logger, level)(message)
        else:
            print(f"[{level.upper()}] {message}")
